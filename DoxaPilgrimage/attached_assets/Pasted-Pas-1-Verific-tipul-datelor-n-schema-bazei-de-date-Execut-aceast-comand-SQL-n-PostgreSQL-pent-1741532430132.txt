Pas 1: VerificÄƒ tipul datelor Ã®n schema bazei de date
ExecutÄƒ aceastÄƒ comandÄƒ SQL Ã®n PostgreSQL pentru a vedea tipurile de date efective:

sql
CopiazÄƒ
EditeazÄƒ
SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'pilgrimages';
DacÄƒ startDate È™i endDate sunt Ã®ncÄƒ text, atunci migrÄƒrile nu au fost aplicate corect.

DacÄƒ foloseÈ™ti SQLite, ruleazÄƒ:

sh
CopiazÄƒ
EditeazÄƒ
sqlite3 dev.db ".schema pilgrimages"
ğŸ”¹ DacÄƒ Ã®ncÄƒ sunt TEXT, trecem la urmÄƒtorul pas pentru a corecta acest lucru.

ğŸ”§ Pas 2: È˜terge È™i recreeazÄƒ migrÄƒrile Drizzle
Ãn terminal, ruleazÄƒ:

sh
CopiazÄƒ
EditeazÄƒ
rm -rf drizzle/migrations
npx drizzle-kit generate:pg
npx drizzle-kit push
sau pentru SQLite:

sh
CopiazÄƒ
EditeazÄƒ
rm -rf drizzle/migrations
npx drizzle-kit generate:sqlite
npx drizzle-kit push
Acest lucru forÈ›eazÄƒ Drizzle sÄƒ regenereze corect tipurile coloanelor.

ğŸ”„ Pas 3: VerificÄƒ dacÄƒ schema este corectÄƒ Ã®n shared/schema.ts
ModificÄƒ schema pentru a te asigura cÄƒ startDate È™i endDate sunt timestamp():

typescript
CopiazÄƒ
EditeazÄƒ
import { pgTable, serial, text, timestamp, numeric } from "drizzle-orm/pg-core";

export const pilgrimages = pgTable("pilgrimages", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  startDate: timestamp("start_date", { mode: "date" }).notNull(),
  endDate: timestamp("end_date", { mode: "date" }).notNull(),
  price: numeric("price").notNull(),
  description: text("description"),
  status: text("status").default("pending"),
});
ğŸ”¹ AdÄƒugarea { mode: "date" } asigurÄƒ cÄƒ timestamp-ul va fi tratat doar ca datÄƒ, fÄƒrÄƒ ora exactÄƒ.

ğŸ”§ Pas 4: VerificÄƒ datele primite de backend (server/routes.ts)
Ãnainte de salvare, adaugÄƒ un console.log() pentru a vedea ce date primeÈ™te serverul:

typescript
CopiazÄƒ
EditeazÄƒ
console.log("Received data:", req.body);
ModificÄƒ È™i conversia datei astfel:

typescript
CopiazÄƒ
EditeazÄƒ
const startDate = new Date(req.body.startDate);
const endDate = new Date(req.body.endDate);

if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
  return res.status(400).json({ message: "Invalid date format", received: req.body });
}

await db.insert(pilgrimages).values({
  title: req.body.title,
  startDate,
  endDate,
  price: parseFloat(req.body.price),
  description: req.body.description,
  status: req.body.status || "pending",
});
ğŸ”¹ DacÄƒ console.log(req.body) aratÄƒ datele Ã®n format string ("2025-03-10T00:00:00.000Z"), atunci problema e Ã®n Drizzle ORM.

ğŸ”„ Pas 5: Trimite datele corect Ã®n frontend (create-pilgrimage-new.tsx)
Ãn loc de toISOString(), Ã®ncearcÄƒ sÄƒ trimiÈ›i data Ã®ntr-un format mai simplu:

typescript
CopiazÄƒ
EditeazÄƒ
const formData = {
  title,
  startDate: startDate.split("T")[0], // TrunchiazÄƒ ora pentru a evita problemele
  endDate: endDate.split("T")[0],
  price: parseFloat(price),
  description,
  status,
};

await fetch("/api/create-pilgrimage", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(formData),
});
ğŸ”¹ DacÄƒ serverul aÈ™teaptÄƒ un timestamp, atunci Ã®ncearcÄƒ sÄƒ trimiÈ›i un Date Ã®n loc de string.

ğŸ“Œ Recapitulare finalÄƒ:
âœ… VerificÄƒ tipul coloanelor Ã®n baza de date (timestamp() sau text()).
âœ… È˜terge È™i recreeazÄƒ migrÄƒrile cu npx drizzle-kit push.
âœ… FoloseÈ™te { mode: "date" } Ã®n schema Drizzle pentru timestamp-uri.
âœ… AdaugÄƒ console.log(req.body) Ã®n backend pentru a verifica ce se trimite.
âœ… Ãn frontend, evitÄƒ toISOString() È™i trunchiazÄƒ ora (split("T")[0]).