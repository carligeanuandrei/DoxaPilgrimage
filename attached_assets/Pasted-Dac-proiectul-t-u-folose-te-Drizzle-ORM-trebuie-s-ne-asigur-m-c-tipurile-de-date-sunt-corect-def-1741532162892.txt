DacÄƒ proiectul tÄƒu foloseÈ™te Drizzle ORM, trebuie sÄƒ ne asigurÄƒm cÄƒ tipurile de date sunt corect definite Ã®n shared/schema.ts È™i cÄƒ baza de date a fost actualizatÄƒ conform acestor modificÄƒri.

ğŸ”¹ 1. VerificÄƒ schema Ã®n shared/schema.ts
Deschide fiÈ™ierul shared/schema.ts È™i cautÄƒ definiÈ›ia tabelului pilgrimages.
Ar trebui sÄƒ arate ceva de genul:

typescript
CopiazÄƒ
EditeazÄƒ
import { pgTable, serial, text, timestamp, numeric } from "drizzle-orm/pg-core";

export const pilgrimages = pgTable("pilgrimages", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date").notNull(),
  price: numeric("price").notNull(),
  description: text("description"),
  status: text("status").default("pending"),
});
ğŸ”¹ DacÄƒ startDate È™i endDate sunt de tip text(), trebuie sÄƒ le schimbÄƒm Ã®n timestamp().
SalveazÄƒ modificÄƒrile dupÄƒ actualizare.

ğŸ”¹ 2. AplicÄƒ migrarea bazei de date cu Drizzle ORM
DupÄƒ ce ai modificat schema, trebuie sÄƒ rulezi migrarea pentru a actualiza baza de date.

Ãn terminal, ruleazÄƒ:

sh
CopiazÄƒ
EditeazÄƒ
npx drizzle-kit generate:pg
npx drizzle-kit push
sau, dacÄƒ foloseÈ™ti SQLite:

sh
CopiazÄƒ
EditeazÄƒ
npx drizzle-kit generate:sqlite
npx drizzle-kit push
ğŸ”¹ VerificÄƒ Ã®n baza de date dacÄƒ modificÄƒrile au fost aplicate.

DacÄƒ foloseÈ™ti PostgreSQL, poÈ›i rula:

sql
CopiazÄƒ
EditeazÄƒ
SELECT column_name, data_type FROM information_schema.columns WHERE table_name = 'pilgrimages';
DacÄƒ foloseÈ™ti SQLite:

sh
CopiazÄƒ
EditeazÄƒ
sqlite3 dev.db ".schema pilgrimages"
DacÄƒ startDate È™i endDate apar Ã®ncÄƒ ca TEXT, atunci migrÄƒrile nu au fost aplicate corect.

ğŸ”¹ 3. Conversia datelor Ã®n Backend (server/routes.ts)
Ãn fiÈ™ierul server/routes.ts, asigurÄƒ-te cÄƒ Ã®nainte de salvare, transformi datele din string Ã®n Date:

typescript
CopiazÄƒ
EditeazÄƒ
const startDate = new Date(req.body.startDate);
const endDate = new Date(req.body.endDate);

if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
  return res.status(400).json({ message: "Invalid date format" });
}

await db.insert(pilgrimages).values({
  title: req.body.title,
  startDate,
  endDate,
  price: parseFloat(req.body.price),
  description: req.body.description,
  status: req.body.status || "pending",
});
ğŸ”¹ AdaugÄƒ console.log(req.body.startDate, startDate); pentru a verifica dacÄƒ datele ajung corect la server.

ğŸ”¹ 4. Conversia Ã®n Frontend (create-pilgrimage-new.tsx)
DacÄƒ datele din frontend sunt trimise ca string, modificÄƒ astfel:

typescript
CopiazÄƒ
EditeazÄƒ
const formData = {
  title,
  startDate: new Date(startDate).toISOString(), // Convertim la format corect
  endDate: new Date(endDate).toISOString(),
  price: parseFloat(price),
  description,
  status,
};

await fetch("/api/create-pilgrimage", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify(formData),
});
ğŸ”¹ AsigurÄƒ-te cÄƒ datele sunt trimise Ã®n format ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ).

ğŸ“Œ Recapitulare:
âœ… VerificÄƒ schema Ã®n shared/schema.ts È™i schimbÄƒ text() Ã®n timestamp().
âœ… RuleazÄƒ migrarea bazei de date cu npx drizzle-kit push.
âœ… Ãn backend, converteÈ™te datele la Date Ã®nainte de salvare.
âœ… Ãn frontend, converteÈ™te datele la .toISOString() Ã®nainte de a le trimite.

DupÄƒ ce aplici aceste modificÄƒri, Ã®ncearcÄƒ din nou salvarea pelerinajului È™i spune-mi dacÄƒ mai apare eroarea!